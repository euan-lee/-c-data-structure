# 04장 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

변수는 실제 메모리 주소를 사람이 쓰기 쉬운 변수명과 매핑시킨것. 저장된 값을 재사용하기 위해 고안된것이다.

## 4.2 식별자

- 식별자는 메모리 주소에 붙인 이름(식별자는 주소와 mapping)
- 직접 메모리 주소를 통해 값을 manipulating 하는것이 아니라, 식별자(변수명)을 통해서 메모리에 있는 값을 manipulating.
- 변수에 국한된것이 아니라, 함수, 클래스 들의 이름은 모두 식별자이다.
  (즉, 메모리상의 어떤 값을 식별 할 수 있는 이름은 모두 식별자)
- declaration에 의해서 자바스크립트 엔진에 식별자의 존재를 알림

## 4.3 변수선언

- declaration: 변수생성: 값을 저장하기위해 메모리 공간을 확보하고 메모리 주소를 연결시켜 값을 저장할 수 있게 준비하는 것.
- 키워드 const, let, var사용
- 선언만 하고 할당을 하지 않으면 ‘undefined’라는 값이 js 엔진에 의해서 초기화.
- 선언 + 초기화단계(최소한 undefined)
- 변수의 이름은 어디에 등록?!: execution context에 등록된다. 변수 이름 + 변수 값은 실행 컨텍스트 내에서 key/value 형식인 객체로 등록되어 관리된다. (13장 스코프, 23장 실행컨텍스트 참고)
- garbage value, var키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다. 선언하지 않은 식별자에 접근하면 ReferenceError(참조에러)가 발생한다: 식별자를 통해서 값을 잠조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을때 발생하는 에러.

## 4.4. 변수 선언의 실행시점과 변수 호이스팅

- 참조코드 vs 선언코드
  - 참조코드가 선언코드가 더 먼저있다면 ReferenceError가 먼저 일어날것 같지만, undefined가 출력!(이미 선언되었다는말!) - **왜냐면 변수의 선언은 runtime이전 단계에서 먼저 실행되기 때문이다.**
- 평가단계 >> 실행단계: 실행단계(한줄한줄 인터프레터) 이전에 평가단계가 먼저 실행되어 ‘선언문(함수, 변수)’을 소스코드에서 먼저 찾아내 실행. 평가과정이 끝나면 실행단계 고고(한줄 한줄): 즉, 자바스크립트 엔진은 변수 선언이 어디에 있던, 실행단계보다 먼저 수행되므로 변수선언을 어디서 하든 어디서든지 참조할 수 있다.
- 호이스팅: 변수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 자바스크립트의 고유특징 (var, let, const, function, function\*, class)

## 4.5. 값의 할당(assignment)

- 선언과 할당을 동시에 (1줄) = 선언과 할당을 따로따로(2줄)
- **단, 선언과 할당의 실행시점이 다르다. (단축표현해도 2줄로 따로따로 하는것과 마찬가지: hoisting)**
- 선언: 평가단계(runtime 이전) vs 할당: 실행단계(runtime)
- **단, 실제 메모리상에서는 undefined라는 값을 비우고 다시 80이라는 값의 재할당이 아니라, 변수를 새로 선언하고 그 80이라는 값을 넣는것이다. (그냥 알아둬)**

## 4.6. 값의 재할당

- 사실 var로 변수 할당하면, undefined >> 실제값 으로 재할당 되는거나 마찬가지이고(아예 새로운 메모리 주소에 새로 할당), 재할당도 그때와 마찬가지로 다른 새로운 메모리 주소에 새로운 값을 할당하는것. **(그렇게 어떤 식별자도 연결되지 않은 값들은 가비지컬렉터에 의해서 자동 해제 - 언제일지는 모름)**
- 가비지컬렉터는 어떤 식별자도 참조하지 않는 메모리 공간을 비워주는 역할
- 매니지드 언어 vs 언매니지드 언어

## 4.7. 식별자 네이밍 규칙
