# 14. 전역 변수의 문제점


- 전역 변수의 무분별한 사용은 위험함
- **전역 변수를 반드시 사용해야하는 경우가 아닐 시 지역 변수를 사용**해야 함



## 14.1 변수의 생명 주기


### [ 1) 지역 변수의 생명 주기 ]


- 전역 변수의 생명 주기 == 애플리케이션의 생명 주기
- (함수 내부의) 지역 변수의 생명 주기 == **함수가 호출되면 생성 (함수 몸체의 코드 순차 실행 전 먼저 생성됨) & 함수가 종료되면 소멸**


```js
function foo() {
    // foo 함수 호출 시 아래 다른 문들이 실행되기 이전에
    // x 변수의 선언문이 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화됨
    var x = 'local'; // 그 다음에야 변수 할당문이 실행되고 x 변수에 값이 할당됨
    console.log(x); 
    return x;
}

foo(); // local
console.log(x); // ReferenceError: x is not defined
```


- 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치, 그러나 지역 변수가 함수보다 오래 생존하는 경우도 있음
- 변수의 생명주기 : 메모리 공간이 확보 allocate된 시점 ~ 메모리 공간이 해제 release되어 가용 메모리 풀에 반환되는 시점
- 지역 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효함

>일반적으로 함수가 종료되면 함수가 생성한 스코프도 소멸하나, <br> **누군가가 스코프를 참조하고 있다면 해당 스코프는 해제되지 않고 생존**하게 됨 (see chapter 24. 클로저)


```js

var x = 'global';

function foo() {
    // 지역 변수 x가 이미 선언된 상태에서 아래 라인이 실행됨 (undefined로 초기화된 상태)
    // 따라서 전역 변수 x가 아니라 지역 변수 x를 참조하여 값을 출력하되, 할당문 실행 전이므로 undefined
    console.log(x); // undefined
    var x = 'local';
}

foo();
console.log(x); // "global"
```


- 위 예제에서와 같이 **호이스팅은 스코프를 단위로 동작**함
- 전역 변수의 호이스팅 : 전역 변수의 선언이 전역 스코프의 선두로 끌어올려진 것처럼 작동 -> 전역 변수는 전역 전체에서 유효
- 지역 변수의 호이스팅 : 지역 변수의 선언이 지역 스코프의 선두로 끌어올려진 것처럼 작동 -> **지역 변수는 함수 전체에서 유효**

>호이스팅 : 변수 선언이 **스코프**의 선두로 끌어올려진 것처럼 동작하는 것


### [ 2) 전역 변수의 생명 주기 ]

- var 키워드로 선언한 전역 변수는 **전역 객체**의 **프로퍼티**가 됨
- 즉, 전역 변수의 생명 주기는 **전역 객체의 생명 주기**와 일치함

<hr>

#### 전역 객체 global object

- 코드가 실행되기 이전 단계에 js 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체
- 클라이언트 사이드 환경(브라우저)에서의 전역 객체 : **window**
- 서버 사이드 환경(Node.js)에서의 전역 객체 : **global 객체**

<br>

- 과거 전역 객체를 가리키던 다양한 식별자(window, self, this, frames, global)가 ES11에서 **globalThis**로 통일됨 

- 전역 객체는 아래 항목들을 **프로퍼티**로 갖고 있음
  1) **표준 빌트인 객체** (Object, String, Number, Function, Array, ...) 
  2) **환경에 따른 호스트 객체** (클라이언트 Web API or Node.js의 호스트 API)
  3) **var 키워드로 선언한 전역 변수 & 전역 함수**

<br>

- 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티
- 전역 객체 window는 웹페이지를 닫기 전까지 유효
- 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹페이지를 닫기 전까지 유효 (전역 객체의 생명 주기와 일치함)



## 14.2 전역 변수의 문제점


### [ 1) 암묵적 결합 ]

- 모든 코드가 전역 변수를 참조 & 변경할 수 있는 암묵적 결합 implicit coupling을 허용하는 것
- 변수의 유효 범위가 클수록 : 가독성 down & 의도치 않은 상태 변경 위험성 up


### [ 2) 긴 생명 주기 ]

- 의도치 않은 재할당이 이뤄질 가능성이 높음 
- 상태 변경에 의한 오류가 발생할 확률이 높아짐


### [ 3) 스코프 체인 상 종점에 존재 ]

- 전역 변수는 스코프 체인 상 종점에 존재하므로,
- 변수 검색 시 전역 변수가 가장 마지막에 검색됨
- 즉, **전역 변수의 검색 속도가 가장 느림**


### [ 4) 네임스페이스 오염 ]

- js는 파일이 분리되어 있더라도 하나의 전역 스코프를 공유하게 됨
- 다른 파일 내 동일 명칭의 전역 변수 & 전역 함수가 같은 스코프에 존재할 시 문제 발생 가능



## 14.3 전역 변수의 사용을 억제하는 방법


### [ 1) 즉시 실행 함수 ]

- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 **즉시 실행 함수의 지역 변수**가 됨
- 즉시 실행 함수는 1회만 호출됨 (함수 정의와 동시에 호출됨)

```js
(function () {
    var foo = 10;
    // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```


### [ 2) 네임스페이스 객체 ]

- 전역에 네임스페이스 역할을 담당할 객체를 생성
- 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 직접 추가
- 네임 스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가하여 네임스페이스를 계층적으로 구성할 수도 있음

```js
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
    name:'Lee',
    address:'Seoul'
};

console.log(MYAPP.person.name); // 'Lee'
```

>결과적으로 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않음


### [ 3) 모듈 패턴 ]

- 클래스를 모방 
- 관련이 있는 변수 & 함수를 모아 즉시실행 함수로 감싸 하나의 모듈로 만듦
- 클로저를 기반으로 동작함
- 전역 변수의 억제는 물론 캡슐화까지 구현 가능
- 다만 js에서는 접근 제한자(public, private, protected 등) 사용 불가

>encapsulation : 객체의 상태 state를 나타내는 프로퍼티 & 프로퍼티를 참조하고 조작할 수 있는 동작 behavior인 메서드를 하나로 묶는 것


```js
var Counter = (function() { 
    // 외부에서 접근 불가한 private member
    var num = 0;

    // 외부에 노출하고 싶은 변수 & 메서드를 프로퍼티로 추가한 객체를 반환
    return {
        increase() { // 반환되는 객체의 프로퍼티는 public member
            return ++num;
        },
        decrease() { // 반환되는 객체의 프로퍼티는 public member
            return --num;
        }
    };
}());

console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

<hr>

(위 예제 관련 질문) 

<span style='color:blue; font-weight:bold;'>어째서 즉시실행 함수인데 num 변수가 그대로 남아 변화가 발생 가능한가?</span> 
<span style='color:blue; font-weight:bold;'>매번 실행 시마다 초기화되는 것이 아닌가?</span>

- 실제로 Counter 변수는 즉시 실행함수의 **return 값**인 아래 **increase & decrease 함수**를 변수의 값으로 갖게 됨 

```js
increase() { // 반환되는 객체의 프로퍼티는 public member
    return ++num;
},
decrease() { // 반환되는 객체의 프로퍼티는 public member
    return --num;
}
```
- 이 때, 위 increase & decrease 함수가 내부적으로 num 변수를 참조하고 있으므로,
- num 변수는 즉시실행함수가 종료되더라도 가비지 콜렉터가 회수하지 않음

- 일반적으로 함수가 종료되면 함수가 생성한 스코프도 소멸하나,
 누군가가 스코프를 참조하고 있다면 해당 스코프는 해제되지 않고 생존하게 되고 & 
 지역 변수는 자신이 등록된 스코프가 소멸될 때까지 유효하므로,
 num 지역 변수는 여전히 유효하고 increase & decrease 함수로 값을 변경하는 것이 반영됨
 

<hr>



### [ 4) ES6 모듈 ]

- ES6(Chrome61, FF60, SF10.1, Edge 16 +) 모듈 사용 시 전역 변수는 더 이상 사용 불가
- ES6 모듈은 **파일 자체의 독자적인 모듈 스코프**를 제공
- **모듈 내**에서 **var** 키워드로 선언한 변수는 전역 변수가 아님 & window 객체의 프로퍼티도 아님

```html
<!-- script 태그에 type='module' 어트리뷰트 추가 시 로드된 js 파일이 모듈로서 작동함 -->
<!-- 모듈 파일 확장자는 mjs를 권장함 -->

<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```

- 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다 **Webpack 등의 모듈 번들러를 사용**하는 것이 일반적 (48장 모듈 & 49장 Babel과 Webpack)