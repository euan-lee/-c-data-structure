## 19장 프로토타입

#### [1. 객체지향 프로그래밍](#1-객체지향-프로그래밍-1)
#### [2. 상속과 프로토타입](#2-상속과-프로토타입-1)
#### [3. 프로로타입 객체](#3-프로로타입-객체-1)
#### [4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입](#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입-1)
#### [5. 프로토타입의 생성 시점](#5-프로토타입의-생성-시점-1)
#### [6. 객체 생성 방식과 프로토타입의 결정](#6-객체-생성-방식과-프로토타입의-결정-1)
#### [7. 프로토타입 체인](#7-프로토타입-체인-1)
#### [8. 오버라이딩과 프로퍼티 섀도잉](#8-오버라이딩과-프로퍼티-섀도잉-1)
#### [9. 프로토타입 교체](#9-프로토타입-교체-1)
#### [10. instanceof 연산자](#10-instanceof-연산자-1)
#### [11. 직접 상속](#11-직접-상속-1)
#### [12. 정적 프로퍼티/메서드](#12-정적-프로퍼티/메서드-1)
#### [13. 프로퍼티 존재 확인](#13-프로퍼티-존재-확인-1)
#### [14. 프로퍼티 열거](#14-프로퍼티-열거-1)

***

 자바스크립트는 명령형 `imperative`, 함수형 `functional`, 프로토타입 기반 `prototype-based` 객체지향 프로그래밍 `OOP` 을 지원하는 멀티 패러다임 프로그래밍
 
### 1. 객체지향 프로그래밍
 > 실세계의 실체(사물이나 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작   
 > 여러 개의 독립적 단위, 즉 객체 `object` 의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
 
 추상화 `abstraction`
  > 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것

 상태 `state` 데이터 (`property`) 와 동작 `behavior` (`method`) 을 하나의 논리적인 단위로 묶은 복합적인 자료구조


### 2. 상속과 프로토타입

 상속 `inheritance`
  > 객체지향 프로그래밍의 핵심 개념, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것

 자바스크립트는 프로토타입 `prototype` 을 기반으로 상속을 구현
 
 
### 3. 프로토타입 객체
 > 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공

 \_\_proto__ 접근자 프로퍼티
  > 모든 객체는 \_\_proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근 할 수 있음

  - \_\_proto__는 접근자 프로퍼티다.
    - get \_\_proto__
      > \_\_proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 [[Get]] 호출
    - set \_\_proto__
      > \_\_proto__ 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 [[Set]] 호출
                        
  - \_\_proto__ 접근자 프로퍼티는 상속을 통해 사용
    > \_\_proto__ 접근자 프로퍼티는 Object.prototype의 프로퍼티

  - \_\_proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유
    > 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해
                                                
  - \_\_proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않음
    - (ES5) Object.getPropertyOf
      > 프로토타입의 참조를 취득하고 싶은 경우
    - (ES6) Object.setPropertyOf
      > 프로토타입을 교체하고 싶은 경우

 함수 객체의 prototype 프로퍼티
  > \_\_proto__ 접근자 프로퍼티와 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킴
  - \_\_proto__ : 모든 객체
  - prototype : 생성자 함수
  
 프로토타입의 constructor 프로퍼티와 생성자 함수
  - 모든 프로토타입은 constructor 프로퍼티를 갖음
  - constructor
     > 자신을 참조하고 있는 생성자 함수를 가리킴 

 
### 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
 > 리터럴 표기법에 의해 생성된 객체의 경우, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.

 - 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍 `pair` 으로 존재
 
 | 리터럴 표기법 | 생성자 함수 | 프로토타입 |
 |---|:---:|:---:|
 | 객체 리터럴 | Object | Object.prototype |
 | 함수 리터럴 | Function | Function.prototype |
 | 배열 리터럴 | Array | Array.prototype |
 | 정규 표현식 리터럴 | RegExp | RegExp.prototype | 


### 5. 프로토타입의 생성 시점

 사용자 정의 생성자 함수
  - constructor
     > 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성
  - non-constructor
     > 프로토타입이 생성되지 않음
                        
 빌트인 생성자 함수
  > 전역 객체가 생성되는 시점에 생성


### 6. 객체 생성 방식과 프로토타입의 결정
 > 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정

 객체 리터럴에 의해 생성된 객체의 프로토타입
  > Object.prototype 

 Object 생성자 함수에 의해 생성된 객체의 프로토타입
  > Object.prototype

 생성자 함수에 의해 생성된 객체의 프로토타입
  > 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체


### 7. 프로토타입 체인
 > 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때,   
   해당 객체에 접근하려는 프로퍼티가 없다면   
   [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색

 프로토타입 체인의 종점 `end of prototype chain`
  - Object.prototype
    > Object.prototype의 [[Prototype]] 내부 슬롯의 값은 null

 프로토타입 체인은 객체지향 프로그래밍의 상속을 구현하기 위한 메커니즘
 
 
### 8. 오버라이딩과 프로퍼티 섀도잉

 오버라이딩 `overriding`
  > 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

 프로퍼티 섀도잉 `property shadowing`
  > 상속 관계에 의해 프로퍼티가 가려지는 현상

 하위 객체를 통해 프로토타입 체인을 통해 접근하여, 프로토타입 프로퍼티를 변경 또는 삭제 불가
  > 프로토타입에 직접 접근


### 9. 프로토타입의 교체
 > 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있음

 생성자 함수에 의한 프로토타입의 교체
  > constructor 프로퍼티와 생성자 함수 간의 연결이 파괴   
  > 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킴

 인스턴스에 의한 프로토타입의 교체
  > constructor 프로퍼티와 생성자 함수 간의 연결이 파괴   
  > 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리키지 않음


### 10. instanceof 연산자

내용 작성

### 11. 직접 상속

내용 작성

### 12. 정적 프로퍼티/메서드

내용 작성

### 13. 프로퍼티 존재 확인

내용 작성

### 14. 프로퍼티 열거

내용 작성


